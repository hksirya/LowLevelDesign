# Low Level Design

![LLD-Banner](https://github.com/hksirya/LowLevelDesign/assets/104431269/a4ced4ab-b96b-40ab-853b-c55d02882c09)
# Objective: Low-Level System Design

   - **Understanding Problem Statements:**
      - **Comprehensive Reading:** Candidates should carefully read and grasp the problem statement, ensuring they understand all details and requirements.
      - **Identifying Core Elements:** They need to dig deeper, figuring out the main aspects that need attention and solving.
      - **Capturing Requirements:** This involves recognizing what the problem is asking for, and what they need to achieve.
   
   - **Optimizing Code using Data Structures:**
      - **Choosing the Right Tools:** Candidates must select the best-suited tools from their coding toolbox, like arrays, lists, trees, etc.
      - **Making Code Efficient:** They should figure out ways to make their code run faster and use less memory.
      - **Understanding Trade-offs:** This means understanding that using one tool might be faster, but could use more memory, and vice versa.
   
   - **Problem Extensions and Coding:**
      - **Being Flexible:** Candidates learn how to be adaptable, handling extra tasks added to the original problem.
      - **Building on Existing Work:** They know how to add new features without starting all over again.
      - **Creating Scalable Solutions:** This involves writing code that can grow and handle more complex tasks if needed.

# Key Results :

   - **Designing a Clear Class Diagram:**
      - **Creating a Map:** Candidates make a visual plan of how different parts of their code fit together.
      - **Understanding Relationships:** They figure out how different parts talk to each other and pass information.
      - **Guiding Implementation:** This map helps them write code in a way that makes sense and is easy to follow.
   
   - **Role in Writing Test Cases:**
      - **Putting Code to the Test:** Candidates ensure their code works well by checking it with various inputs and situations.
      - **Anticipating Challenges:** They think about what could go wrong and write tests to catch those issues.
      - **Validating Solutions:** By running tests, candidates confirm that their code solves the problem in different scenarios.
   
   - **Code Optimization:**
      - **Streamlining Processes:** Candidates work on making their code faster and not use unnecessary memory.
      - **Using Efficient Steps:** They identify ways to take fewer steps to solve the problem without sacrificing accuracy.
      - **Making Code Faster:** Optimizing means making their code run quicker and more smoothly.
   
   - **Addressing Key Requirements:**
      - **Focusing on Essentials:** Candidates concentrate on solving the main parts of the problem, not getting caught up in less important details.
      - **Choosing What Matters:** They know what parts of the problem are most important and tackle those first.
      - **Solving the Heart of the Issue:** Addressing key requirements means solving the heart of the problem.
